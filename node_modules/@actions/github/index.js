const { readFileSync } = require('fs');

function loadPayload() {
  const eventPath = process.env.GITHUB_EVENT_PATH;
  if (!eventPath) {
    return {};
  }

  try {
    const content = readFileSync(eventPath, 'utf8');
    return JSON.parse(content);
  } catch (error) {
    console.warn('Failed to read GitHub event payload:', error);
    return {};
  }
}

function loadRepo(payload) {
  if (process.env.GITHUB_REPOSITORY) {
    const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
    return { owner, repo };
  }

  const owner = payload?.repository?.owner?.login;
  const repo = payload?.repository?.name;
  return { owner, repo };
}

const payload = loadPayload();
const context = {
  payload,
  repo: loadRepo(payload)
};

function encodePath(path) {
  return path
    .split('/')
    .map((segment) => encodeURIComponent(segment))
    .join('/');
}

function getOctokit(token) {
  if (!token) {
    throw new Error('A GitHub token is required to create an Octokit instance.');
  }

  const apiBaseUrl = process.env.GITHUB_API_URL || 'https://api.github.com';

  async function requestJson(url, options = {}) {
    const response = await fetch(url, {
      method: options.method || 'GET',
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: 'application/vnd.github+json',
        'User-Agent': 'code-review-assistant-action',
        'X-GitHub-Api-Version': '2022-11-28',
        ...(options.headers || {}),
        ...(options.body ? { 'Content-Type': 'application/json' } : {})
      },
      body: options.body ? JSON.stringify(options.body) : undefined
    });

    const data = await response.json();

    if (!response.ok) {
      const error = new Error(`GitHub API request failed with status ${response.status}`);
      error.status = response.status;
      error.response = data;
      throw error;
    }

    return { data };
  }

  const pulls = {
    listFiles: ({ owner, repo, pull_number, per_page = 30, page = 1 }) => {
      const url = `${apiBaseUrl}/repos/${owner}/${repo}/pulls/${pull_number}/files?per_page=${per_page}&page=${page}`;
      return requestJson(url);
    },
    get: ({ owner, repo, pull_number }) => {
      const url = `${apiBaseUrl}/repos/${owner}/${repo}/pulls/${pull_number}`;
      return requestJson(url);
    },
    listReviewComments: ({ owner, repo, pull_number, per_page = 30, page = 1 }) => {
      const url = `${apiBaseUrl}/repos/${owner}/${repo}/pulls/${pull_number}/comments?per_page=${per_page}&page=${page}`;
      return requestJson(url);
    },
    createReviewComment: ({ owner, repo, pull_number, body, commit_id, path, line, side, in_reply_to }) => {
      const url = `${apiBaseUrl}/repos/${owner}/${repo}/pulls/${pull_number}/comments`;
      const payload = in_reply_to
        ? { body, in_reply_to }
        : { body, commit_id, path, line, side };
      return requestJson(url, { method: 'POST', body: payload });
    }
  };

  const repos = {
    getContent: ({ owner, repo, path, ref }) => {
      const encodedPath = encodePath(path);
      const url = `${apiBaseUrl}/repos/${owner}/${repo}/contents/${encodedPath}${ref ? `?ref=${encodeURIComponent(ref)}` : ''}`;
      return requestJson(url);
    }
  };

  return {
    rest: {
      pulls,
      repos
    }
  };
}

async function paginate(method, parameters, mapFn) {
  const results = [];
  const perPage = parameters && parameters.per_page ? parameters.per_page : 30;
  let page = 1;

  while (true) {
    const response = await method({ ...parameters, page, per_page: perPage });
    const items = typeof mapFn === 'function' ? mapFn(response) : response.data;
    results.push(...items);

    if (!Array.isArray(response.data) || response.data.length < perPage) {
      break;
    }

    page += 1;
  }

  return results;
}

module.exports = {
  context,
  getOctokit,
  paginate
};
