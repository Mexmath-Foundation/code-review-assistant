const { readFileSync } = require('fs');

function loadPayload() {
  const eventPath = process.env.GITHUB_EVENT_PATH;
  if (!eventPath) {
    return {};
  }

  try {
    const content = readFileSync(eventPath, 'utf8');
    return JSON.parse(content);
  } catch (error) {
    console.warn('Failed to read GitHub event payload:', error);
    return {};
  }
}

function loadRepo(payload) {
  if (process.env.GITHUB_REPOSITORY) {
    const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
    return { owner, repo };
  }

  const owner = payload?.repository?.owner?.login;
  const repo = payload?.repository?.name;
  return { owner, repo };
}

const payload = loadPayload();
const context = {
  payload,
  repo: loadRepo(payload)
};

function getOctokit(token) {
  if (!token) {
    throw new Error('A GitHub token is required to create an Octokit instance.');
  }

  const apiBaseUrl = process.env.GITHUB_API_URL || 'https://api.github.com';

  async function requestJson(url) {
    const response = await fetch(url, {
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: 'application/vnd.github+json',
        'User-Agent': 'code-review-assistant-action',
        'X-GitHub-Api-Version': '2022-11-28'
      }
    });

    const data = await response.json();

    if (!response.ok) {
      const error = new Error(`GitHub API request failed with status ${response.status}`);
      error.status = response.status;
      error.response = data;
      throw error;
    }

    return { data };
  }

  return {
    rest: {
      pulls: {
        listFiles: ({ owner, repo, pull_number, per_page = 30, page = 1 }) => {
          const url = `${apiBaseUrl}/repos/${owner}/${repo}/pulls/${pull_number}/files?per_page=${per_page}&page=${page}`;
          return requestJson(url);
        }
      }
    }
  };
}

async function paginate(method, parameters, mapFn) {
  const results = [];
  const perPage = parameters && parameters.per_page ? parameters.per_page : 30;
  let page = 1;

  while (true) {
    const response = await method({ ...parameters, page, per_page: perPage });
    const items = typeof mapFn === 'function' ? mapFn(response) : response.data;
    results.push(...items);

    if (!Array.isArray(response.data) || response.data.length < perPage) {
      break;
    }

    page += 1;
  }

  return results;
}

module.exports = {
  context,
  getOctokit,
  paginate
};
